# 学习freemarker
##  背景：
* Spring Boot 2.0.2
* tomcat 8.5.31
* jdk 1.8
* maven 3.3.9
* freemarker 2.3.24

在线手册： http://freemarker.foofun.cn/index.html

## 什么是 FreeMarker?

1. 模板引擎
2. 一个Java类库
3. 可嵌入开发产品的组件
4. 模板 + 数据模型 = 输出

### 数据模型
数据模型是哈希表:被"(root)"所标识的内容就是哈希表类型的值
```injectedfreemarker
(root)
 |
 +- mouse = "Yerri"
     |
     +- age = 12
     |
     +- color = "brown"
```
#### 数值

#### 类型
* 标量
标量是最基本，最简单的数值类型
    * 字符串
    * 数字
    * 布尔值
    * 日期/时间(日期、时间或日期时间)

* 容器
这些值存在的目的是为了包含其他变量；它们只是容器。 它们包含的变量通常视为 subvariables (子变量，译者注)。
    * 哈希表

        每个子变量都可以通过一个唯一的名称来查找
    * 序列

        每个子变量通过一个整数来标识。从0开始
    * 集合

        集合是有限制的序列。


* 子程序
    * 方法和函数

        方法和函数有什么区别呢？

        这是模板作者所关心的， 它们没有关系，但也不是一点关系都没有。 方法是来自于数据模型 (它们反射了Java对象的方法) 而函数是定义在模板内的 (使用 function 指令 -- 也是高级话题)，但二者可以用同一种方式来使用。
    * 用户自定义指令

        这种类型的值可以作为用户自定义指令(换句话说，就是FreeMarker的标签) 用户自定义指令是一种子程序，一种可以复用的模板代码段。
    * 函数/方法和用户自定义指令的比较

        这部分内容也是对高级用户来说的(如果还不能理解可以先忽略它)。 如果要使用函数/方法或自定义指令去实现一些东西的时候， 二者之间的选择是两难的。按经验来说，如果能够实现需求， 请先用自定义指令而不要用函数/方法。如果：

            ... 输出(返回值)的是标记(HTML,XML等)。 主要原因是函数的返回结果可以自动进行XML转义(这是因为 ${...} 的特性)， 而用户自定义指令的输出则不是 (这是因为 <@...> 的特性所致; 它的输出假定是标记，因此已经转义过了)。

            ... 副作用也是很重要的一点，它没有返回值。 例如一个指令的目的是往服务器日志中添加一条。 (事实上不能得到自定义指令的返回值， 但有些反馈的类型是有可能设置非本地变量的。)

            ... 会进行流程的控制(就像 list 或 if 指令那样)。但是不能在函数/方法上这么做。

        在模板中，FreeMarker不知道的Java对象的方法通常是可以作为方法来使用的， 而不用考虑Java对象方法本身的特性，因为在这里没有其他的选择。
* 其他
    * 节点

#### 总结
* 树形结构
* 标量用于存储单一的值。这种类型的值可以是字符串，数字，日期/时间或者是布尔值。
* 哈希表是一种存储变量及其相关且有唯一标识名称的容器
* 序列是存储有序变量的容器。存储的变量可以通过数字索引来检索，索引通常从0开始。
### 模板
实际上用程序语言编写的程序就是模板

* FreeMarker所解析的特殊代码片段

    * ${...}：(插值) :FreeMarker将会输出真实的值来替换大括号内的表达式，这样的表达式被称为 interpolation(插值，译者注)。

    * FTL 标签 (FreeMarker模板的语言标签)(指令)： FTL标签和HTML标签有一些相似之处，但是它们是FreeMarker的指令，是不会在输出中打印的。 这些标签的名字以 # 开头。(用户自定义的FTL标签则需要使用 @ 来代替 #，但这属于更高级的话题了。)

    * 注释： 注释和HTML的注释也很相似， 但是它们使用 <#-- and --> 来标识。 不像HTML注释那样，FTL注释不会出现在输出中(不出现在访问者的页面中)， 因为 FreeMarker会跳过它们。

    FTL是区分大小写的
    插值 仅仅可以在 文本 中使用
    FTL 标签 不可以在其他 FTL 标签 和 插值中使用
    注释 可以放在 FTL 标签 和 插值中

* 指令

* 表达式
    * 直接指定值
        * 字符串： "Foo" 或者 'Foo' 或者 "It's \"quoted\"" 或者 'It\'s "quoted"' 或者 r"C:\raw\string"
        * 数字： 123.45
        * 布尔值： true， false
        *  序列： ["foo", "bar", 123.45]； 值域： 0..9, 0..<10 (或 0..!10), 0..
        * 哈希表： {"name":"green mouse", "price":150}
    *  检索变量
        *  顶层变量： user
        *   从哈希表中检索数据： user.name， user["name"]
        *  从序列中检索数据： products[5]
        *   特殊变量： .main
    *   字符串操作
        *   插值(或连接)： "Hello ${user}!" (或 "Hello " + user + "!")
        *   获取一个字符： name[0]
        *    字符串切分： 包含结尾： name[0..4]，不包含结尾： name[0..<5]，基于长度(宽容处理)： name[0..*5]，去除开头： name[5..]
    *   序列操作
        *   连接： users + ["guest"]
        *   序列切分：包含结尾： products[20..29]， 不包含结尾： products[20..<30]，基于长度(宽容处理)： products[20..*10]，去除开头： products[20..]
        * 值域:值域也是序列，但它们由指定包含的数字范围所创建， 而不需指定序列中每一项
            * 值域表达式的通用形式是( start 和 end 可以是任意的结果为数字表达式)：
                * start..end： 包含结尾的值域。比如 1..4 就是 [1, 2, 3, 4]， 而 4..1 就是 [4, 3, 2, 1]。当心一点， 包含结尾的值域不会是一个空序列，所以 0..length-1 就是 错误的，因为当长度是 0 时， 序列就成了 [0, -1]。
                * start..<end 或 start..!end： 不包含结尾的值域。比如 1..<4 就是 [1, 2, 3]，4..<1 就是 [4, 3, 2], 而 1..<1 表示 []。请注意最后一个示例； 结果可以是空序列，和 ..< 和 ..! 没有区别; 最后这种形式在应用程序中使用了 < 字符而引发问题(如HTML编辑器等)。
                * start..*length： 限定长度的值域，比如 10..*4 就是 [10, 11, 12, 13]，10..*-4 就是 [10, 9, 8, 7]，而 10..*0 表示 []。当这些值域被用来切分时， 如果切分后的序列或者字符串结尾在指定值域长度之前，则切分不会有问题；请参考 序列切分 来获取更多信息。
                * start..： 无右边界值域。这和限制长度的值域很像，只是长度是无限的。 比如 1.. 就是 [1, 2, 3, 4, 5, 6, ... ]，直到无穷大。 但是处理(比如列表显示)这种值域时要万分小心，处理所有项时， 会花费很长时间，直到内存溢出应用程序崩溃。 和限定长度的值域一样，当它们被切分时， 遇到切分后的序列或字符串结尾时，切分就结束了。

    * 哈希表操作
        *  连接： passwords + { "joe": "secret42" }
    *  算术运算： (x * 1.5 + 10) / 2 - y % 100
    *  比较运算： x == y， x != y， x < y， x > y， x >= y， x <= y， x lt y， x lte y， x gt y， x gte y， 等等。。。。。。
    *   逻辑操作： !registered && (firstVisit || fromEurope)
    *  内建函数： name?upper_case, path?ensure_starts_with('/')
    *   方法调用： repeat("What", 3)
    *   处理不存在的值：
        *   默认值： name!"unknown" 或者 (user.name)!"unknown" 或者 name! 或者 (user.name)!
        *   检测不存在的值： name?? 或者 (user.name)??
    *   赋值操作： =, +=, -=, *=, /=, %=, ++, --

* 联合使用指令

    在页面上也可以多次使用指令，而且指令间也可以很容易地相互嵌套
    ```injectedfreemarker
    <#list animals as animal>
          <div<#if animal.protected> class="protected"</#if>>
            ${animal.name} for ${animal.price} Euros
          </div>
    </#list>
    ```
    请注意，FreeMarker并不解析FTL标签以外的文本、插值和注释， 上面示例在HTML属性中使用FTL标签也不会有问题。


* 内建函数


* 处理不存在的变量
    * 变量名后面跟着一个 !(叹号，译者注)和默认值
    ```injectedfreemarker
    <h1>Welcome ${user!"visitor"}!</h1>

    <p>Price: ${animals.python.price!0}</p><#--当且仅当 animals.python 永远存在， 而仅仅最后一个子变量 price 可能不存在时是正确的-->
    <p>Price: ${(animals.python.price)!0}</p> <#--animals、python 也可以不存在-->
    ```
    * 变量名后面通过放置 ?? 来询问一个变量是否存在
    ```injectedfreemarker
    <#if user??><h1>Welcome ${user}!</h1></#if>

    <#if animals.python.price??><h1>Price:  ${animals.python.price}</h1></#if>
    <#if (animals.python.price)??><h1>Price:  ${animals.python.price}</h1></#if>
    ```



